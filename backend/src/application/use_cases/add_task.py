"""Add task use case - evolved from Phase I with user ownership."""

from datetime import datetime

from src.application.dto.task_dto import TaskDTO, SubtaskDTO
from src.application.dto.task_input_dto import TaskInputDTO
from src.domain.entities.task import Task, Subtask
from src.domain.repositories.task_repository import TaskRepository


class AddTaskUseCase:
    """
    Use case for adding a new task.

    This implements the application logic for creating tasks,
    coordinating between the interface and domain layers.

    Responsibilities:
        - Accept TaskInputDTO from interface layer
        - Create Task entity with auto-generated ID
        - Persist Task via repository
        - Return TaskDTO to interface layer

    Business Rules:
        - Title and description are validated by Task entity
        - ID is auto-generated by repository (serial)
        - user_id must reference existing user
        - completed defaults to False
        - created_at and updated_at are set to current timestamp
    """

    def __init__(self, task_repository: TaskRepository) -> None:
        """
        Initialize use case with repository dependency.

        Args:
            task_repository: Repository for task persistence
        """
        self._task_repository = task_repository

    def execute(self, task_input: TaskInputDTO) -> TaskDTO:
        """
        Execute the add task use case.

        Args:
            task_input: Task input data (user_id, title, description, completed)

        Returns:
            TaskDTO with auto-generated ID and timestamps

        Raises:
            ValidationError: If task data violates business rules
            EntityNotFoundError: If user_id does not exist
        """
        # Create timestamp
        now = datetime.utcnow()

        # Convert subtask DTOs to domain entities
        subtasks = tuple(
            Subtask(id=s.id, text=s.text, completed=s.completed)
            for s in task_input.subtasks
        )

        # Create domain entity (ID will be 0, replaced by repository)
        task = Task(
            id=0,  # Placeholder - repository will generate serial ID
            user_id=task_input.user_id,
            title=task_input.title,
            description=task_input.description,
            completed=task_input.completed,
            priority=task_input.priority,
            tags=task_input.tags,
            due_date=task_input.due_date,
            subtasks=subtasks,
            created_at=now,
            updated_at=now,
        )

        # Persist via repository (returns task with generated ID)
        saved_task = self._task_repository.add(task)

        # Convert to DTO for interface layer
        return TaskDTO(
            id=saved_task.id,
            user_id=saved_task.user_id,
            title=saved_task.title,
            description=saved_task.description,
            completed=saved_task.completed,
            priority=saved_task.priority,
            tags=saved_task.tags,
            due_date=saved_task.due_date,
            subtasks=tuple(
                SubtaskDTO(id=s.id, text=s.text, completed=s.completed)
                for s in saved_task.subtasks
            ),
            created_at=saved_task.created_at,
            updated_at=saved_task.updated_at,
        )
