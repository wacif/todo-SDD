---
name: phr.0002.hackathon-ii-constitution-alignment
description: "stage=constitution | date=2025-12-12 | surface=VS Code | branch=feat/dashboard-redesign | command=/sp.constitution | spec=.specify/memory/constitution.md"
model: "GPT-5.2 (Preview)"
---

## Prompt

/sp.constitution as you see we have done alot of the work. but now i want to take a step back and now we have to make our project totally align with the requirements. and now we have to create each spec again. but now the complete specifications then we will create plans and tasks for each one and move step by step. start from the constitution .Hackathon II
The Evolution of Todo ‚Äì Mastering Spec-Driven Development & Cloud Native AI

The future of software development is AI-native and spec-driven. As AI agents like Claude Code become more powerful, the role of the engineer shifts from "syntax writer" to "system architect." We have already explored Spec-Driven Book Authoring. Now, we want you to master the Architecture of Intelligence.
In this hackathon, you will master the art of building applications iteratively‚Äîstarting from a simple console app and evolving it into a fully-featured, cloud-native AI chatbot deployed on Kubernetes. This journey will teach you the Nine Pillars of AI-Driven Development, Claude Code, Spec-Driven Development with Reusable Intelligence and Cloud-Native AI technologies through hands-on implementation.
Excel in the Hackathon and Launch Your Journey as an AI Startup Founder üöÄ
We've recently launched Panaversity (panaversity.org), an initiative focused on teaching cutting-edge AI courses. If you perform well in this hackathon, you may be invited for an interview to join the Panaversity core team and potentially step into the role of a startup founder within this growing ecosystem. You will get a chance to work with Panaversity founders Zia, Rehan, Junaid, and Wania and become the very best. You may also get a chance to teach at Panaversity, PIAIC, and GIAIC.
What You Will Learn
Spec-Driven Development using Claude Code and Spec-Kit Plus
Reusable Intelligence: Agents Skills and Subagent Development
Full-Stack Development with Next.js, FastAPI, SQLModel, and Neon Serverless Database
AI Agent Development using OpenAI Agents SDK and Official MCP SDK
Cloud-Native Deployment with Docker, Kubernetes, Minikube, and Helm Charts
Event-Driven Architecture using Kafka and Dapr
AIOps with kubectl-ai, kagent and Claude Code
Develop Cloud-Native Blueprints for Spec-Driven Deployment

Research Note: Deployment Blueprints for Spec-Driven Deployment
Is Spec-Driven Development Key for Infrastructure Automation?
ChatGPT Progressive Learning Conversation
Spec-Driven Cloud-Native Architecture: Governing AI Agents for Managed Services with Claude Code and SpecKit

Requirements
You are required to complete the 5-Phase "Evolution of Todo" Project using Claude Code and Spec-Kit Plus. The core deliverables are:
Spec-Driven Implementation: You must implement all 5 Phases of the project (detailed below). You are strictly required to use Spec-Driven Development. You must write a Markdown Constitution and Spec for every feature of the phase, and use Claude Code to generate the implementation.
Constraint: You cannot write the code manually. You must refine the Spec until Claude Code generates the correct output.
Integrated AI Chatbot: In Phases III, IV, and V, you must implement a conversational interface using OpenAI Chatkit, OpenAI Agents SDK, and Official MCP SDK. The bot must be able to manage the user's Todo list via natural language (e.g., "Reschedule my morning meetings to 2 PM").
Cloud Native Deployment: In Phases IV and V, you must deploy the chatbot locally on Minikube, and on the cloud on DigitalOcean Kubernetes (DOKS). 
Todo App Feature Progression
Basic Level (Core Essentials)
These form the foundation‚Äîquick to build, essential for any MVP:
Add Task ‚Äì Create new todo items
Delete Task ‚Äì Remove tasks from the list
Update Task ‚Äì Modify existing task details
View Task List ‚Äì Display all tasks
Mark as Complete ‚Äì Toggle task completion status
Intermediate Level (Organization & Usability)
Add these to make the app feel polished and practical:


Priorities & Tags/Categories ‚Äì Assign levels (high/medium/low) or labels (work/home)
Search & Filter ‚Äì Search by keyword; filter by status, priority, or date
Sort Tasks ‚Äì Reorder by due date, priority, or alphabetically
Advanced Level (Intelligent Features)
Recurring Tasks ‚Äì Auto-reschedule repeating tasks (e.g., "weekly meeting")
Due Dates & Time Reminders ‚Äì Set deadlines with date/time pickers; browser notifications
Use Agentic Dev Stack for building this hackathon project.
Hackathon Phases Overview
Phase
Description
Technology Stack
Points
Due Date
Phase I
In-Memory Python Console App
Python, Claude Code, Spec-Kit Plus
100
Dec 7, 2025
Phase II
Full-Stack Web Application
Next.js, FastAPI, SQLModel, Neon DB
150
Dec 14, 2025
Phase III
AI-Powered Todo Chatbot
OpenAI ChatKit, Agents SDK, Official MCP SDK
200
Dec 21, 2025
Phase IV
Local Kubernetes Deployment
Docker, Minikube, Helm, kubectl-ai, kagent
250
Jan 4, 2026
Phase V
Advanced Cloud Deployment
Kafka, Dapr, DigitalOcean DOKS
300
Jan 18, 2026
TOTAL




1,000




Bonus Points
Participants can earn additional bonus points for exceptional implementations:
Bonus Feature
Points
Reusable Intelligence ‚Äì Create and use reusable intelligence via Claude Code Subagents and Agent Skills
+200
Create and use Cloud-Native Blueprints via Agent Skills
+200
Multi-language Support ‚Äì Support Urdu in chatbot
+100
Voice Commands ‚Äì Add voice input for todo commands
+200
TOTAL BONUS
+600



Timeline
Submission Deadline: On Sundays on dates as mentioned above.
Live Presentations: On Sundays, December 7, 14, and 21, 2025 and on January 4 and 18, 2026 starting at 8:00 PM on Zoom. Final Live Presentation date to be determined.

Top submissions will be invited via WhatsApp to present live on Zoom. 
Note: All submissions will be evaluated. Live presentation is by invitation only, but does not affect final scoring. 
Milestone
Date
Description
Hackathon Start
Monday, Dec 1, 2025
Documentation released
Phase I Due
Sunday, Dec 7, 2025
Console app checkpoint
Phase II Due
Sunday, Dec 14, 2025
Web app checkpoint
Phase III Due
Sunday, Dec 21, 2025
Chatbot checkpoint
Phase IV Due
Sunday, Jan 4, 2026
Local K8s checkpoint
Final Submission
Sunday, Jan 18, 2026
All phases complete
Live Presentations
Sundays, Dec 7, 14, 21, and Jan 4 and 18
Top submissions present


Submit and Present Your Project:

Once you have completed the project you will submit your project here at each phase:

https://forms.gle/KMKEKaFUD6ZX4UtY8 

Submit the following via the form for each phase (You can submit a phase before the due date):
Public GitHub Repo Link
Published App Link for Vercel. 
Include a demo video link (must be under 90 seconds). Judges will only watch the first 90 seconds. You can use NotebookLM or record your demo.
WhatsApp number (top submissions will be invited to present live)
Everyone is welcome to join the Zoom meeting to watch the presentations. Only invited participants will present their submissions. The meetings start at 8:00 PM on Sundays.

Join Zoom Meeting
Time: 08:00 PM On Sundays, December 7, 14, and 21, 2025 and on January 4, 2026 starting at 8:00 PM on Zoom. Final Live Presentation date to be determined.
https://us06web.zoom.us/j/84976847088?pwd=Z7t7NaeXwVmmR5fysCv7NiMbfbhIda.1 
Meeting ID: 849 7684 7088
Passcode: 305850



















Project Details: The Evolution of Todo
Focus and Theme: From CLI to Distributed Cloud-Native AI Systems.
Goal: Students act as Product Architects, using AI to build progressively complex software without writing boilerplate code.

Project Overview
This project simulates the real-world evolution of software. You will start with a simple script and end with a Kubernetes-managed, event-driven, AI-powered distributed system.
Phase Breakdown

Phase I: Todo In-Memory Python Console App
Basic Level Functionality
Objective: Build a command-line todo application that stores tasks in memory using Claude Code and Spec-Kit Plus.
üí°Development Approach: Use the Agentic Dev Stack workflow: Write spec ‚Üí Generate plan ‚Üí Break into tasks ‚Üí Implement via Claude Code. No manual coding allowed. We will review the process, prompts, and iterations to judge each phase and project.
Requirements
Implement all 5 Basic Level features (Add, Delete, Update, View, Mark Complete)
Use spec-driven development with Claude Code and Spec-Kit Plus
Follow clean code principles and proper Python project structure
Technology Stack
UV
Python 3.13+
Claude Code
Spec-Kit Plus
Deliverables
GitHub repository with:
Constitution file 
specs history folder containing all specification files
/src folder with Python source code
README.md with setup instructions
CLAUDE.md with Claude Code instructions

Working console application demonstrating:
Adding tasks with title and description
Listing all tasks with status indicators
Updating task details
Deleting tasks by ID
Marking tasks as complete/incomplete
Windows Users: WSL 2 Setup
Windows users must use WSL 2 (Windows Subsystem for Linux) for development:
# Install WSL 2
wsl --install
 
# Set WSL 2 as default
wsl --set-default-version 2
 
# Install Ubuntu
wsl --install -d Ubuntu-22.04

Phase II: Todo Full-Stack Web Application
Basic Level Functionality
Objective: Using Claude Code and Spec-Kit Plus transform the console app into a modern multi-user web application with persistent storage.
üí°Development Approach: Use the Agentic Dev Stack workflow: Write spec ‚Üí Generate plan ‚Üí Break into tasks ‚Üí Implement via Claude Code. No manual coding allowed. We will review the process, prompts, and iterations to judge each phase and project.
Requirements
Implement all 5 Basic Level features as a web application
Create RESTful API endpoints
Build responsive frontend interface
Store data in Neon Serverless PostgreSQL database
Authentication ‚Äì Implement user signup/signin using Better Auth
Technology Stack
Layer
Technology
Frontend
Next.js 16+ (App Router)
Backend
Python FastAPI
ORM
SQLModel
Database
Neon Serverless PostgreSQL
Spec-Driven
Claude Code + Spec-Kit Plus
Authentication
Better Auth

API Endpoints
Method
Endpoint
Description
GET
/api/{user_id}/tasks
List all tasks
POST
/api/{user_id}/tasks
Create a new task
GET
/api/{user_id}/tasks/{id}
Get task details
PUT
/api/{user_id}/tasks/{id}
Update a task
DELETE
/api/{user_id}tasks/{id}
Delete a task
PATCH
/api/{user_id}tasks/{id}/complete
Toggle completion


Securing the REST API
Better Auth + FastAPI Integration
The Challenge
Better Auth is a JavaScript/TypeScript authentication library that runs on your Next.js frontend. However, your FastAPI backend is a separate Python service that needs to verify which user is making API requests.
The Solution: JWT Tokens
Better Auth can be configured to issue JWT (JSON Web Token) tokens when users log in. These tokens are self-contained credentials that include user information and can be verified by any service that knows the secret key.
How It Works
User logs in on Frontend ‚Üí Better Auth creates a session and issues a JWT token
Frontend makes API call ‚Üí Includes the JWT token in the Authorization: Bearer <token> header
Backend receives request ‚Üí Extracts token from header, verifies signature using shared secret
Backend identifies user ‚Üí Decodes token to get user ID, email, etc. and matches it with the user ID in the URL
Backend filters data ‚Üí Returns only tasks belonging to that user
What Needs to Change
Component
Changes Required
Better Auth Config
Enable JWT plugin to issue tokens
Frontend API Client
Attach JWT token to every API request header
FastAPI Backend
Add middleware to verify JWT and extract user
API Routes
Filter all queries by the authenticated user's ID

The Shared Secret
Both frontend (Better Auth) and backend (FastAPI) must use the same secret key for JWT signing and verification. This is typically set via environment variable BETTER_AUTH_SECRET in both services.
Security Benefits
Benefit
Description
User Isolation
Each user only sees their own tasks
Stateless Auth
Backend doesn't need to call frontend to verify users
Token Expiry
JWTs expire automatically (e.g., after 7 days)
No Shared DB Session
Frontend and backend can verify auth independently

API Behavior Change
After Auth:
All endpoints require valid JWT token
Requests without token receive 401 Unauthorized
Each user only sees/modifies their own tasks
Task ownership is enforced on every operation

Bottom Line
The REST API endpoints stay the same (GET /api/user_id/tasks, POST /api/user_id/tasks, etc.), but every request now must include a JWT token, and all responses are filtered to only include that user's data.

## Response snapshot

- Amended `.specify/memory/constitution.md` to align with Hackathon II: added spec re-baselining rules, clarified security/auth expectations, and bumped version/date.
- Updated Spec-Kit templates to embed explicit constitution gates and phase metadata.

## Outcome

- ‚úÖ Impact: Constitution now explicitly enforces re-baselining specs before new work and captures Phase II auth boundary expectations.
- üß™ Tests: N/A (docs/templates only)
- üìÅ Files: Updated constitution + templates
- üîÅ Next prompts: Recreate Phase I/II feature specs under `specs/` and proceed `/sp.plan` ‚Üí `/sp.tasks` per feature.
- üß† Reflection: Keeping spec artifacts authoritative prevents drift as the project evolves across phases.

## Evaluation notes (flywheel)

- Failure modes observed: N/A
- Graders run and results (PASS/FAIL): N/A
- Prompt variant (if applicable): N/A
- Next experiment (smallest change to try): Create Phase II ‚ÄúTask CRUD + Auth‚Äù specs with acceptance scenarios that map 1:1 to tests.
